# 운영 모드와 레지스터
## 보호 모드의 레지스터
- 프로그램 실행에 관련된 기본 레지스터

|32비트 범용 레지스터|
|---|
|EAX|
|EBX|
|ECX|
|EDX|
|ESI|
|EDI|
|ESP|
|EBP|

|인스트럭션 포인터 레지스터|
|---|
|32비트 EIP|

|16비트 세그먼트 레지스터|
|---|
|CS|
|DS|
|ES|
|FS|
|GS|
|SS|

- 시스템에 관련된 레지스터

|32비트 컨트롤 레지스터|
|---|
|CR0|
|CR1|
|CR2|
|CR3|
|CR4|

|플래그 레지스터|
|---|
|32비트 EFLAGS|

|글로벌 디스크립터 테이블 레지스터|
|---|
|48비트 GDTR|

|인터럽트 디스크립터 테이블 레지스터|
|---|
|48비트 IDTR|

|로컬 디스크립터 테이블 레지스터|
|---|
|16비트 LDTR|

|태스크 레지스터|
|---|
|16비트 TR|

|모델 고유 레지스터|
|---|
|MSR|

## 64비트 범용 레지스터
- x86-64 프로세서에는 아래처럼 많은 레지스터가 있지만, 큰 비중을 차지하는 레지스터는 [범용 레지스터](#범용-레지스터), [세그먼트 레지스터](#세그먼트-레지스터), [컨트롤 레지스터](#컨트롤-레지스터) 세 가지이다.

- 프로그램 실행에 관련된 기본 레지스터

|64비트 범용 레지스터|용도|
|---|---|
|RAX|산술 연산|
|RBX|데이터의 주소를 지정할 때 데이터 포인터로 사용|
|RCX|루프 또는 문자열의 카운터로 사용|
|RDX|I/O 주소를 지정할 때, 산술 연산을 수행할 때 보조 레지스터로 사용|
|RSI|문자열에 관련된 작업을 수행할 때 원본 문자열의 인덱스로 사용|
|RDI|문자열에 관련된 작업을 수행할 때 목적지 문자열의 인덱스로 사용|
|RSP|스택의 포인터로 사용|
|RBP|스택의 데이터에 접근할 때 데이터의 포인터로 사용|
|R8 ~ R15|다양한 용도로 사용 가능|

|인스트럭션 포인터 레지스터|
|---|
|64비트 RIP|

|16비트 세그먼트 레지스터|
|---|
|CS|
|DS|
|ES|
|FS|
|GS|
|SS|

- 실수 연산 및 SIMD 관련 레지스터

|80비트 FPU 레지스터|
|---|
|(8개)|

|64비트 MMX 레지스터|
|---|
|(8개)|

|128비트 XMM 레지스터|
|---|
|(16개)|

- 시스템에 관련된 레지스터

|64비트 컨트롤 레지스터|
|---|
|CR0|
|CR1|
|CR2|
|CR3|
|CR8|

|플래그 레지스터|
|---|
|64비트 RFLAGS|

|글로벌 디스크립터 테이블 레지스터|
|---|
|80비트 GDTR|

|인터럽트 디스크립터 테이블 레지스터|
|---|
|80비트 IDTR|

|로컬 디스크립터 테이블 레지스터|
|---|
|16비트 LDTR|

|태스크 레지스터|
|---|
|16비트 TR|

|모델 고유 레지스터|
|---|
|MSR|

## 범용 레지스터
- General Purpose Register
- 계산, 메모리 주소 지정, 임시 저장 공간
- 32비트 호환 프로세서 - 8개
- 64비트 호환 프로세서 - 16개

*범용 레지스터의 수가 늘어나면 어떤 장점이 있을까?*

대표적인 장점은 수행 속도의 개선이다. 관련된 값을 레지스터에 모두 올려서 계산함으로써 메모리에 접근하는 시간을 줄일 수 있다.

함수 호출에도 그대로 적용된다. 다수의 범용 레지스터에 함수 파라미터를 넘겨줌으로써 스택 영역의 메모리에 접근하는 시간과 스택을 정리하는 시간을 줄일 수 있다.

범용 레지스터의 용도는 고정된 것이 아니다. 하지만 특정 명령어는 특정 레지스터와 같이 사용해야 한다.

*예: PC에 연결된 디바이스를 제어하려면 장치가 연결된 I/O 주소에 접근해야 한다. 이 때 I/O 주소를 저장할 수 있는 레지스터는 DX밖에 없다.*

*예: 스택은 LIFO 형태의 자료구조다. 스택은 SP와 BP 레지스터를 사용하며, 데이터를 넣고 꺼낼 때마다 이들을 조절함으로써 자료구조를 유지한다.*

**x86-64 프로세서는 64비트 크기의 범용 레지스터만 있으며 보호 모드나 리얼 모드일 때 개별적인 레지스터를 사용하는 것이 아니라 같은 레지스터의 일부 영역만 사용하도록 처리하고 있다.**

접두사, 접미사를 붙여서 접근하는 크기를 표시한다.

예:

|64|32|16|
|---|---|---|
|RAX|EAX|AX(AH, AL)|
|RBX|EBX|BX(BH, BL)|
|R8|R8D|R8W(-, R8L)|

리얼 모드에서 이런 접두사를 사용해서까지 다른 크기의 레지스터에 접근하는 것은 매우 특수한 상황이다.

*IA-32a 모드의 기본 오퍼랜드(연산 대상)의 크기는 32비트이다. 그럼 어떻게 64비트 주소를 표현할까?*

64비트 RIP 레지스터는 현재 수행 중인 명령의 주소를 가리키는 레지스터이다.
이름과 같이 크기가 64비트이다.

RIP 레지스터의 값과 32비트 오퍼랜드를 통해 64비트 주소 공간을 나타낼 수 있다.

RIP 레지스터에 명령어의 주소를 저장하고, 명령어의 오퍼랜드 부분에는 상대적인 오프셋이 저장된다. 둘을 더하면 명령어에서 사용된 데이터의 실제 메모리 주소가 나온다.

## 세그먼트 레지스터
## 컨트롤 레지스터
